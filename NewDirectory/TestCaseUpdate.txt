```python
# imports
import pytest  # used for our unit tests

# function to test
def factorial(x):
    if x == 1:
        return 1
    else:
        return (x * factorial(x-1))

# unit tests
# below, each test case is represented by a tuple passed to the @pytest.mark.parametrize decorator

@pytest.mark.parametrize("test_input,expected_output", [
    (1, 1),  # factorial of 1 is 1
    (5, 120),  # factorial of 5 is 120
    (10, 3628800),  # factorial of 10 is 3628800
    (0, 1),  # factorial of 0 is 1
])
def test_factorial(test_input, expected_output):
    assert factorial(test_input) == expected_output

def test_factorial_negative():
    # factorial is not defined for negative numbers, so we expect a RecursionError
    with pytest.raises(RecursionError):
        factorial(-5)

def test_factorial_non_integer():
    # factorial is not defined for non-integers, so we expect a TypeError
    with pytest.raises(TypeError):
        factorial(5.5)
    with pytest.raises(TypeError):
        factorial("5")

def test_factorial_large_input():
    # factorial of 100 is a very large number, but it should still return the correct result
    assert factorial(100) == 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
```
This suite of tests covers the cases outlined in the previous discussion. It uses the `pytest.mark.parametrize` decorator to test multiple inputs and expected outputs for the `factorial` function. It also includes tests for negative numbers, non-integers, and large inputs, which are expected to raise errors or return specific results.