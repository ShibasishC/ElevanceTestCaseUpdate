```python
# imports
import pytest  # used for our unit tests

# function to test
def factorial(x):
    if x == 1:
        return 1
    else:
        return (x * factorial(x-1))

# unit tests
# below, each test case is represented by a tuple passed to the @pytest.mark.parametrize decorator

# Test the function with positive integers
@pytest.mark.parametrize("test_input, expected_output", [(5, 120), (3, 6)])
def test_factorial_positive_integers(test_input, expected_output):
    assert factorial(test_input) == expected_output

# Test the function with 1 as input
def test_factorial_one():
    assert factorial(1) == 1

# Test the function with 0 as input
def test_factorial_zero():
    assert factorial(0) == 1

# Test the function with negative integers
def test_factorial_negative_integers():
    with pytest.raises(RecursionError):
        factorial(-5)

# Test the function with non-integer inputs
def test_factorial_non_integer():
    with pytest.raises(TypeError):
        factorial(2.5)
    with pytest.raises(TypeError):
        factorial('a')

# Test the function with large integer inputs
def test_factorial_large_integer():
    assert factorial(100) == 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000

# Test the function with None as input
def test_factorial_none():
    with pytest.raises(TypeError):
        factorial(None)
```
This suite of tests covers a wide range of possible inputs and edge cases for the `factorial` function. Each test asserts that the function behaves as expected for a given input, and raises an appropriate error for invalid inputs.