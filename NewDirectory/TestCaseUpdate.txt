```python
# imports
import pytest  # used for our unit tests

# function to test
def factorial(x):
    if x == 1:
        return 1
    else:
        return (x * factorial(x-1))

# unit tests
# below, each test case is represented by a tuple passed to the @pytest.mark.parametrize decorator

# Test for positive integer inputs
@pytest.mark.parametrize("test_input, expected_output", [(5, 120), (10, 3628800)])
def test_factorial_positive_integers(test_input, expected_output):
    assert factorial(test_input) == expected_output

# Test for input of 1
def test_factorial_one():
    assert factorial(1) == 1

# Test for input of 0
def test_factorial_zero():
    assert factorial(0) == 1

# Test for negative integer inputs
def test_factorial_negative_integers():
    with pytest.raises(RecursionError):
        factorial(-5)

# Test for non-integer inputs
@pytest.mark.parametrize("test_input", [5.5, '5'])
def test_factorial_non_integer(test_input):
    with pytest.raises(TypeError):
        factorial(test_input)

# Test for large integer inputs
def test_factorial_large_integer():
    with pytest.raises(RecursionError):
        factorial(1000)
```
In the above code, each function decorated with `@pytest.mark.parametrize` or `def test_...` is a separate test case. The `assert` statement is used to check if the output of the `factorial` function matches the expected output. If the output does not match, the test will fail. The `with pytest.raises(...)` statement is used to check if the function raises the expected exception for invalid inputs.