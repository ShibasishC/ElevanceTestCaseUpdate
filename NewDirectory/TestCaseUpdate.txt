```python
# imports
import pytest  # used for our unit tests

# function to test
def factorial(x):
    if x == 1:
        return 1
    else:
        return (x * factorial(x-1))

# unit tests
# below, each test case is represented by a tuple passed to the @pytest.mark.parametrize decorator

# Test the function's behavior for positive integers
@pytest.mark.parametrize("test_input, expected_output", [(5, 120), (3, 6)])
def test_factorial_positive_integers(test_input, expected_output):
    assert factorial(test_input) == expected_output

# Test the function's behavior for large numbers
@pytest.mark.parametrize("test_input, expected_output", [(50, 30414093201713378043612608166064768844377641568960512000000000000), (100, 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000)])
def test_factorial_large_numbers(test_input, expected_output):
    assert factorial(test_input) == expected_output

# Test the function's behavior for small numbers
@pytest.mark.parametrize("test_input, expected_output", [(1, 1), (0, 1)])
def test_factorial_small_numbers(test_input, expected_output):
    assert factorial(test_input) == expected_output

# Test the function's behavior for negative integers
# Here, we expect the function to raise a RecursionError for negative inputs
@pytest.mark.parametrize("test_input", [-5, -10])
def test_factorial_negative_integers(test_input):
    with pytest.raises(RecursionError):
        factorial(test_input)

# Test the function's behavior for non-integer inputs
# Here, we expect the function to raise a TypeError for non-integer inputs
@pytest.mark.parametrize("test_input", [2.5, 'a'])
def test_factorial_non_integer_inputs(test_input):
    with pytest.raises(TypeError):
        factorial(test_input)
```
This suite of unit tests covers the diverse scenarios listed above. Each test case is represented by a tuple passed to the `@pytest.mark.parametrize` decorator. The `test_input` is the argument to the `factorial` function, and the `expected_output` is the expected return value of the function. For negative integers and non-integer inputs, we expect the function to raise a `RecursionError` and `TypeError` respectively, so we use `pytest.raises` to check for these exceptions.